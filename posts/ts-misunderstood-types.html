<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="/css/simple.css" />
        <link rel="stylesheet" href="/css/styles.css" />
        <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"> -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/obsidian.min.css">
        <title>TypeScript: sometimes-misunderstood types</title>
    </head>
    <body>
        <main><style>
h2 {
    padding-top: 1.5rem;
}
</style>
<h1 id="typescriptsomet" tabindex="-1">TypeScript: sometimes-misunderstood types</h1>
<h2 id="tableofcontents" tabindex="-1">Table of Contents</h2>
<ul>
<li><a href="#booleannumberst"><code>boolean</code>/<code>number</code>/<code>string</code> vs Boolean/Number/String</a></li>
<li><a href="#void">void</a></li>
<li><a href="#never">never</a></li>
<li><a href="#theemptyinterfa">The empty interface <code>{}</code></a></li>
<li><a href="#classinstancety">Class instance types</a></li>
<li><a href="#json">JSON</a></li>
</ul>
<h2 id="booleannumberst" tabindex="-1"><code>boolean</code>/<code>number</code>/<code>string</code> vs Boolean/Number/String</h2>
<p>The first three covert primitives values, such as <code>true</code>, <code>false</code>, <code>123</code>, <code>&quot;hello&quot;</code>, and so on.</p>
<p>The latter three, on the other hand, are interfaces. For an object to be assignable to <code>Boolean</code>,
it just needs a <code>valueOf(): boolean</code> method:</p>
<pre><code class="language-ts">const example1: Boolean = {
    valueOf() {
        return true;
    }
};

const example2: Number = {
    valueOf() {
        return  0;
    },
    toExponential() {
        return '';
    },
    toFixed() {
        return '';
    },
    toPrecision() {
        return '';
    }
};
</code></pre>
<p>In most cases, Boolean/Number/String are used by mistake, where <code>boolean</code>/<code>number</code>/<code>string</code> should have been used instead.</p>
<h2 id="void" tabindex="-1">void</h2>
<p>Any value can be assigned to void; it indicates that the return value of a function will not be used.</p>
<p>It's intended for one-liner callbacks, like so:</p>
<pre><code class="language-ts">function forEach(items: string[], fn: (value: string) =&gt; undefined) {
    for (const item of items) {
        fn(item)
    }
}

let joined = ''
const words = ['hello', 'world'];

forEach(words, word =&gt; joined += ' ' + word)
//                     ^^^^^^^^^^^^^^^^^^^^
// Type 'string' is not assignable to type 'undefined'.
</code></pre>
<p>We can fix the error by changing the signature to <code>fn: (value: string) =&gt; void</code>. Another valid option is <code>fn: (value: string) =&gt; unknown</code>, but <code>void</code> signals that <code>forEach</code> won't use the callback's result.</p>
<h2 id="never" tabindex="-1">never</h2>
<p><code>never</code> is also intended as a return type, this time signalling that a function never returns.</p>
<p>It's meant to be used in functions that always throw, call <code>process.exit()</code>, or terminate execution in a similar way.</p>
<pre><code class="language-ts">function fail(message: string) {
    console.error(`Failure:`, message);
    throw new Error(message);
}

function example(data: { url?: string }): string {
    if (data.url === undefined) {
        fail('url missing');
    }
    return data.url;
//  ^^^^^^
//  Type 'string | undefined' is not assignable to type 'string'.
}
</code></pre>
<p>We can fix the above snippet by changing <code>fail</code>'s signature to <code>function fail(message: string): never</code>. Now TypeScript can see that if <code>data.url</code> is undefined, the return statement is never reached.</p>
<h2 id="theemptyinterfa" tabindex="-1">The empty interface <code>{}</code></h2>
<p>This is sometimes misunderstood as &quot;an object with no properties&quot;. In reality, TypeScript allows excess properties (otherwise it wouldn't be possible for a single object to satisfy multiple interfaces). Therefore, <code>{}</code> is any value that <strong>can</strong> have properties, which only excludes <code>null</code> and <code>undefined</code>.</p>
<pre><code class="language-ts">const user = { name: 'john', role: 'admin' };

// Both of these typecheck
const user2: { name: string } = user;
const user3: {} = user;
</code></pre>
<p>TypeScript only complains about excess properties in a few scenarios, where there's likely a mistake:</p>
<pre><code class="language-ts">function example(data: { name: string, role?: string }) {}

example({ name: 'john', title: 'admin' });
//                      ^^^^^
// Object literal may only specify known properties, and 'title' does not exist in type '{ name: string; role: string; }'.
</code></pre>
<h2 id="classinstancety" tabindex="-1">Class instance types</h2>
<pre><code class="language-ts">class Person {
    name: string;

    constructor(name: string) {
        this.name = name;
    }
}

const person: Person = { name: 'john' };
</code></pre>
<p>The above snippet typechecks and works as intended. TypeScript is a structurally typed-language, which means that for two types to be compatible, they just need to have the same properties.</p>
<p>In this case, an object is assingnable to the instance type of a class as long as it has all the required properties. It doesn't need to be an actual instance of the class.</p>
<p>This is in stark constrast to languages like Java, where even two identical classes aren't assignable to each other.</p>
<h2 id="json" tabindex="-1">JSON</h2>
<p>I've seen this type being misused a few times this way:</p>
<pre><code class="language-ts">function fetchInfo(): Promise&lt;JSON&gt; {
    return fetch('/info').then(res =&gt; res.json())
}
</code></pre>
<p>The <code>JSON</code> type is just the methods of the global <code>JSON</code> object, as in <code>{ parse(data: string): any, stringify(data: any): string }</code>.</p>
<pre><code class="language-ts">// This typechecks, but makes no sense and probably isn't what was intended.
const info = await fetchInfo();
info.stringify(123);
info.parse(&quot;123&quot;);
</code></pre>
<p>There isn't a &quot;JSON data&quot; type, simply because JSON is a way encoding JS objects, and not a type in itself.</p>
<p>The correct way to type the previous function would be:</p>
<pre><code class="language-ts">function fetchInfo(): Promise&lt;unknown&gt; {
    return fetch('/info').then(res =&gt; res.json())
}
</code></pre>
</main>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
        <script src="https://unpkg.com/@highlightjs/cdn-assets@11.11.1/languages/typescript.min.js"></script>
        <script>hljs.highlightAll();</script>
    </body>
</html>
